"use client"

import React, { Suspense, useRef, useState } from "react"
import { getFullPath } from "@/helpers/pathHelper"
import {
  CameraControls,
  Environment,
  Loader,
  Stats,
  useGLTF,
  useKTX2,
  useProgress,
  useTexture,
} from "@react-three/drei"
import { Canvas, useFrame } from "@react-three/fiber"
import { folder, Leva, useControls } from "leva"
import * as THREE from "three"
import { GLTF } from "three-stdlib"

import { BMWCar2 } from "@/components/3d/bmw-car-2"
import { ToneMapping } from "@/components/3d/tone-mapping"
import {
  AudioPlayer,
  type AudioPlayerControls,
} from "@/components/misc/audio-player"

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

type GLTFResult = GLTF & {
  nodes: {
    Terrain: THREE.Mesh
    Sand_Flat: THREE.Mesh
    Sand_Flat_2: THREE.Mesh
    Road: THREE.Mesh
  }
  materials: {
    ["Wheatgrass_Mat.041_9.008"]: THREE.MeshStandardMaterial
    ["Wheatgrass_Mat.041_9.009"]: THREE.MeshStandardMaterial
    ["Wheatgrass_Mat.041_0.002"]: THREE.MeshStandardMaterial
  }
}

// @ts-expect-error temp ignore
function Terrain(props) {
  const [roadBase, roadRoughness, terrainBase] = useKTX2([
    getFullPath("/terrain/road-roughness-base.ktx2"),
    getFullPath("/terrain/road-roughness-metal.ktx2"),
    getFullPath("/terrain/terrain-base.ktx2"),
  ])

  const { nodes, materials } = useGLTF(
    getFullPath("/terrain/terrain-scene-without-ktx-texture.glb")
  ) as GLTFResult

  // const rotation = useControls("Terrain Rotation", {
  //   x: { value: 0, min: -180, max: 180, step: 0.0001 },
  //   y: { value: 1.572, min: -180, max: 180, step: 0.0001 },
  //   z: { value: 0, min: -180, max: 180, step: 0.0001 },
  // })

  const sandTexture = terrainBase.clone()
  sandTexture.repeat.set(4, 1)
  sandTexture.wrapS = sandTexture.wrapT = THREE.RepeatWrapping
  sandTexture.needsUpdate = true

  return (
    <group name="CustomTerrain" {...props} dispose={null}>
      <mesh
        name="Terrain"
        castShadow={false}
        receiveShadow={false}
        geometry={nodes.Terrain.geometry}
        material={materials["Wheatgrass_Mat.041_9.008"]}
        position={[-0.102, 1.185, -1.685]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[21.827, 24.702, 6.172]}
        material-map={terrainBase}
        material-color={"#8b002b"}
      />
      <mesh
        name="Sand_Flat"
        castShadow={false}
        receiveShadow={false}
        geometry={nodes.Sand_Flat.geometry}
        material={materials["Wheatgrass_Mat.041_9.008"]}
        material-map={sandTexture}
        position={[-3.86, 0.12, -1.685]}
        rotation={[0, 1.572, 0]}
        scale={[15.827, 16.702, 6.172]}
        material-color={"#8b002b"}
        material-roughness={1}
      />
      <mesh
        name="Sand_Flat"
        castShadow={false}
        receiveShadow={false}
        geometry={nodes.Sand_Flat.geometry}
        material={materials["Wheatgrass_Mat.041_9.008"]}
        material-map={sandTexture}
        position={[3.86, 0.12, -1.685]}
        rotation={[0, 1.572, 0]}
        scale={[15.827, 16.702, 6.172]}
        material-color={"#8b002b"}
        material-roughness={1}
      />
      <mesh
        name="Sand_Flat_2"
        castShadow={false}
        receiveShadow={false}
        geometry={nodes.Sand_Flat_2.geometry}
        material={materials["Wheatgrass_Mat.041_9.009"]}
        position={[7.837, 0.154, 10.251]}
        scale={[3.856, 3.856, 4.15]}
        material-map={terrainBase}
        material-color={"#8b002b"}
      />
      <mesh
        name="Road"
        castShadow={true}
        receiveShadow={true}
        geometry={nodes.Road.geometry}
        material={materials["Wheatgrass_Mat.041_0.002"]}
        position={[0.12, 0.191, -1.564]}
        scale={[15.642, 15.642, 15.96]}
        material-map={roadBase}
        material-roughnessMap={roadRoughness}
        material-metalnessMap={roadRoughness}
      />
    </group>
  )
}

useGLTF.preload(getFullPath("/terrain/terrain-scene-without-ktx-texture.glb"))

function LoopingTerrain() {
  const groupRef = useRef<THREE.Group>(null!)

  // --- Configuration ---
  const segmentLength = 31.6
  const segmentCount = 3
  const loopDistance = segmentLength * segmentCount

  const speed = -10 // Changed from 5 to -5

  useFrame((_, delta) => {
    if (!groupRef.current) return

    groupRef.current.children.forEach((segment) => {
      const mesh = segment as THREE.Group

      mesh.position.z += speed * delta

      if (mesh.position.z < -segmentLength) {
        mesh.position.z += loopDistance
      }
    })
  })

  return (
    <group ref={groupRef}>
      {Array.from({ length: segmentCount }).map((_, i) => {
        const initialZ = i * segmentLength - loopDistance + segmentLength
        return <Terrain key={i} position={[0, 0, initialZ]} />
      })}
    </group>
  )
}

function Lights() {
  const { color } = useControls("Light Props", {
    color: "#f2171a",
  })

  return (
    <>
      {/* <ambientLight intensity={Math.PI * 0.5} /> */}
      {/* <CameraTrackingLight castShadow={false} /> */}
      <directionalLight
        intensity={1}
        // color={"yellow"}
        color={color}
        castShadow
        receiveShadow={false}
        position={[5, 10, 7.5]}
        shadow-mapSize-width={1024}
        shadow-mapSize-height={1024}
      />
    </>
  )
}

function Overlay({
  loadingDone,
  onStartClick,
  started, // Receive the new 'started' prop
}: {
  loadingDone: boolean
  onStartClick: () => void
  started: boolean // Prop type
}) {
  // We can simplify this by just using the prop 'started'
  if (!loadingDone || started) return null

  return (
    <div
      className="pointer-events-auto absolute left-0 top-0 flex size-full flex-col items-center justify-center text-white transition-opacity duration-500"
      onClick={() => {
        // No need for local setClicked, just call the parent handler
        onStartClick()
      }}
      style={{
        zIndex: 100,
        background: "rgba(0, 0, 0, 1)",
      }}
    >
      <h1 className="animate-pulse cursor-pointer text-3xl font-bold">
        Click to Continue
      </h1>
      <p className="mt-2 text-sm text-gray-400">
        Loading complete. Please click to start the experience.
      </p>
    </div>
  )
}

function SelectEnv() {
  const { backgroundRotation, environmentRotation, ...props } = useControls(
    "Environment",
    {
      background: folder({
        backgroundBlurriness: { value: 0, min: 0, max: 1 },
        backgroundIntensity: { value: 1, min: 0, max: 1 },
        backgroundRotation: { value: 2, min: 0, max: Math.PI },
      }),
      environment: folder({
        environmentIntensity: { value: 1, min: 0, max: 1 },
        environmentRotation: { value: 2, min: 0, max: Math.PI },
      }),
    }
  )

  return (
    <Environment
      background
      // preset="warehouse"
      files={getFullPath("/sunset-seaside-low.jpg")}
      {...props}
      backgroundRotation={[0, backgroundRotation, 0]}
      environmentRotation={[0, environmentRotation, 0]}
    />
  )
}

function BackgroundPoster() {
  const [texture] = useTexture([getFullPath("/sunset-car/sunset-seaside.webp")])
  return (
    <mesh
      position={[-0.16, 0.39, -17.415]}
      castShadow={false}
      receiveShadow={false}
    >
      <planeGeometry args={[56, 55]} />
      <meshBasicMaterial map={texture} />
    </mesh>
  )
}

// Keep the original camera rig for reference
// function OriginalCameraRig() {
//   const { disableCameraRig } = useControls("Camera Rig", {
//     disableCameraRig: { value: false, label: "Disable Camera Rig" },
//   })

//   const controls = useThree((state) => state.controls)

//   const [vec] = useState(() => new THREE.Vector3())
//   useFrame((state) => {
//     if (!disableCameraRig) {
//       state.camera.position.lerp(
//         vec.set(-state.pointer.x * 2.5, 1 + state.pointer.y * 3, 5.5),
//         0.05
//       )
//       state.camera.lookAt(0, 0, 0)
//       controls
//     }
//   })

//   return (
//     <OrbitControls
//       enableDamping={disableCameraRig}
//       enablePan={disableCameraRig}
//       enableZoom={disableCameraRig}
//       maxPolarAngle={1.3}
//       enabled={disableCameraRig}
//     />
//   )
// }

function CameraRig({ started }: { started: boolean }) {
  const { disableCameraRig } = useControls("Camera Rig", {
    disableCameraRig: { value: false, label: "Disable Camera Rig" },
  })
  const cameraControlRef = useRef<CameraControls | null>(null)
  const [vec] = useState(() => new THREE.Vector3())
  const lastPosition = useRef(new THREE.Vector3(0, 6, 12))
  const targetPosition = useRef(new THREE.Vector3(0, 1, 5.5))
  const progress = useRef(0)

  // Animate camera on start click
  useFrame((state, delta) => {
    const controls = cameraControlRef.current
    if (!controls) return

    if (started && progress.current < 1) {
      // Ease in over ~2 seconds
      progress.current = Math.min(progress.current + delta * 0.5, 1)
      lastPosition.current.lerpVectors(
        new THREE.Vector3(0, 6, 12),
        targetPosition.current,
        progress.current
      )
      controls.setLookAt(
        lastPosition.current.x,
        lastPosition.current.y,
        lastPosition.current.z,
        0,
        0,
        0,
        false
      )
    } else if (started && progress.current >= 1 && !disableCameraRig) {
      // Once animation complete, enable pointer-based camera rig
      const targetX = -state.pointer.x * 2.5
      const targetY = Math.max(1, 1 + state.pointer.y * 3)
      const targetZ = 5.5
      vec.set(targetX, targetY, targetZ)
      lastPosition.current.lerp(vec, 0.05)
      controls.setLookAt(
        lastPosition.current.x,
        lastPosition.current.y,
        lastPosition.current.z,
        0,
        0,
        0,
        false
      )
    }
  })

  return (
    <CameraControls
      ref={cameraControlRef}
      makeDefault
      enabled={disableCameraRig}
      maxPolarAngle={1.3}
    />
  )
}

export default function App() {
  const { loaded, total } = useProgress()
  const loadingDone = loaded === total
  const [started, setStarted] = useState(false)

  // ✅ Single ref for controlling the car music
  const audioControlsRef = useRef<AudioPlayerControls | null>(null)

  const handleStartClick = () => {
    setStarted(true)
    // ✅ Play the music after the user clicks
    audioControlsRef.current?.play()
  }

  return (
    <main className="noise w-full overflow-x-auto">
      <Leva collapsed />

      <Loader
        dataStyles={{ fontSize: "30px" }}
        dataInterpolation={(p) => `Loading ${p.toFixed(0.1)}%`}
      />

      <Overlay
        loadingDone={loadingDone}
        onStartClick={handleStartClick}
        started={started}
      />

      <Canvas shadows camera={{ position: [0, 3, 34], fov: 45 }}>
        <color attach="background" args={["#000"]} />
        <Lights />

        <Suspense fallback={null}>
          <BackgroundPoster />
          <LoopingTerrain />
          <BMWCar2 />
          <SelectEnv />
          <AudioPlayer
            ref={audioControlsRef}
            src={getFullPath("/music/car-beat.mp3")}
            volume={0.6}
            loop
          />
        </Suspense>

        <CameraRig started={started} />
        <ToneMapping />
        <Stats />
      </Canvas>
    </main>
  )
}
