"use client"

import React, { Suspense, useEffect, useRef, useState } from "react"
import { getFullPath } from "@/helpers/pathHelper"
import {
  CameraControls,
  Environment,
  Html,
  Stats,
  useGLTF,
  useKTX2,
  useTexture,
} from "@react-three/drei"
import { Canvas, useFrame } from "@react-three/fiber"
import { Leva, useControls } from "leva"
import * as THREE from "three"
import { GLTF } from "three-stdlib"

import { IntroOverlay } from "@/components/ui/intro-overlay"
import { BMWCar2 } from "@/components/3d/bmw-car-2"
import { ToneMapping } from "@/components/3d/tone-mapping"
import {
  AudioPlayer,
  type AudioPlayerControls,
} from "@/components/misc/audio-player"

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

type GLTFResult = GLTF & {
  nodes: {
    Terrain: THREE.Mesh
    Sand_Flat: THREE.Mesh
    Sand_Flat_2: THREE.Mesh
    Road: THREE.Mesh
  }
  materials: {
    ["Wheatgrass_Mat.041_9.008"]: THREE.MeshStandardMaterial
    ["Wheatgrass_Mat.041_9.009"]: THREE.MeshStandardMaterial
    ["Wheatgrass_Mat.041_0.002"]: THREE.MeshStandardMaterial
  }
}

// @ts-expect-error temp ignore
function Terrain(props) {
  const [roadBase, roadRoughness, terrainBase] = useKTX2([
    getFullPath("/terrain/road-roughness-base.ktx2"),
    getFullPath("/terrain/road-roughness-metal.ktx2"),
    getFullPath("/terrain/terrain-base.ktx2"),
  ])

  const { nodes, materials } = useGLTF(
    getFullPath("/terrain/terrain-scene-without-ktx-texture.glb")
  ) as GLTFResult

  // const rotation = useControls("Terrain Rotation", {
  //   x: { value: 0, min: -180, max: 180, step: 0.0001 },
  //   y: { value: 1.572, min: -180, max: 180, step: 0.0001 },
  //   z: { value: 0, min: -180, max: 180, step: 0.0001 },
  // })

  const { terrainColor } = useControls("Terrain Color", {
    terrainColor: "#8b002b",
  })
  const sandTexture = terrainBase.clone()
  sandTexture.repeat.set(4, 1)
  sandTexture.wrapS = sandTexture.wrapT = THREE.RepeatWrapping
  sandTexture.needsUpdate = true

  return (
    <group name="CustomTerrain" {...props} dispose={null}>
      <mesh
        name="Terrain"
        castShadow={false}
        receiveShadow={false}
        geometry={nodes.Terrain.geometry}
        material={materials["Wheatgrass_Mat.041_9.008"]}
        position={[-0.102, 1.185, -1.685]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[21.827, 24.702, 6.172]}
        material-map={terrainBase}
        // material-color={"#8b002b"}
        material-color={terrainColor}
      />
      <mesh
        name="Sand_Flat"
        castShadow={false}
        receiveShadow={false}
        geometry={nodes.Sand_Flat.geometry}
        material={materials["Wheatgrass_Mat.041_9.008"]}
        material-map={sandTexture}
        position={[-3.86, 0.12, -1.685]}
        rotation={[0, 1.572, 0]}
        scale={[15.827, 16.702, 6.172]}
        // material-color={"#8b002b"}
        material-color={terrainColor}
        material-roughness={1}
      />
      <mesh
        name="Sand_Flat"
        castShadow={false}
        receiveShadow={false}
        geometry={nodes.Sand_Flat.geometry}
        material={materials["Wheatgrass_Mat.041_9.008"]}
        material-map={sandTexture}
        position={[3.86, 0.12, -1.685]}
        rotation={[0, 1.572, 0]}
        scale={[15.827, 16.702, 6.172]}
        // material-color={"#8b002b"}
        material-color={terrainColor}
        material-roughness={1}
      />
      <mesh
        name="Sand_Flat_2"
        castShadow={false}
        receiveShadow={false}
        geometry={nodes.Sand_Flat_2.geometry}
        material={materials["Wheatgrass_Mat.041_9.009"]}
        position={[7.837, 0.154, 10.251]}
        scale={[3.856, 3.856, 4.15]}
        material-map={terrainBase}
        // material-color={"#8b002b"}
        material-color={terrainColor}
      />
      <mesh
        name="Road"
        castShadow={true}
        receiveShadow={true}
        geometry={nodes.Road.geometry}
        material={materials["Wheatgrass_Mat.041_0.002"]}
        position={[0.12, 0.191, -1.564]}
        scale={[15.642, 15.642, 15.96]}
        material-map={roadBase}
        material-roughnessMap={roadRoughness}
        material-metalnessMap={roadRoughness}
      />
    </group>
  )
}

useGLTF.preload(getFullPath("/terrain/terrain-scene-without-ktx-texture.glb"))

function LoopingTerrain() {
  const groupRef = useRef<THREE.Group>(null!)

  // --- Configuration ---
  const segmentLength = 31.6
  const segmentCount = 3
  const loopDistance = segmentLength * segmentCount

  const speed = -10 // Changed from 5 to -5

  useFrame((_, delta) => {
    if (!groupRef.current) return

    groupRef.current.children.forEach((segment) => {
      const mesh = segment as THREE.Group

      mesh.position.z += speed * delta

      if (mesh.position.z < -segmentLength) {
        mesh.position.z += loopDistance
      }
    })
  })

  return (
    <group ref={groupRef}>
      {Array.from({ length: segmentCount }).map((_, i) => {
        const initialZ = i * segmentLength - loopDistance + segmentLength
        return <Terrain key={i} position={[0, 0, initialZ]} />
      })}
    </group>
  )
}

function Lights() {
  const { color } = useControls("Light Props", {
    // color: "#f2171a",
    color: "#ffffff",
  })

  return (
    <>
      <directionalLight
        intensity={1}
        color={color}
        receiveShadow={false}
        position={[5, 10, 7.5]}
        shadow-mapSize-width={1024}
        shadow-mapSize-height={1024}
      />
    </>
  )
}

function SelectEnv() {
  const { environmentRotation, environmentIntensity } = useControls(
    "Environment",
    {
      environmentIntensity: { value: 1.55, min: 0, max: 5, step: 0.01 },
      environmentRotation: { value: 2, min: 0, max: Math.PI },
    }
  )

  return (
    <Environment
      files={getFullPath("/sunset-car/sunset-seaside-low.jpg")}
      environmentIntensity={environmentIntensity}
      environmentRotation={[0, environmentRotation, 0]}
    />
  )
}

function BackgroundPoster() {
  const [texture] = useTexture([getFullPath("/sunset-car/sunset-seaside.webp")])

  const { opacity } = useControls("BackgroundImage", {
    opacity: { value: 1, min: 1, max: 10, step: 0.001 },
  })
  useEffect(() => {
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping
    texture.colorSpace = "srgb"
    texture.repeat.set(3, 1)
    texture.needsUpdate = true
  }, [texture])

  return (
    <mesh
      // position={[-0.16, 1.39, -17.415]}
      position={[0, 2, 0]}
      castShadow={false}
      receiveShadow={false}
      // scale={4}
      scale={800}
      // rotation={[0, 1, 0]}
      rotation={[0, THREE.MathUtils.degToRad(120), 0]}
    >
      {/* <planeGeometry args={[56, 55]} /> */}
      <cylinderGeometry args={[1, 1, 1, 32, 1, true]} />

      <meshBasicMaterial
        map={texture}
        // transparent
        opacity={opacity}
        side={THREE.DoubleSide}
        fog={false}
      />
    </mesh>
  )
}

function BackgroundSmoke() {
  const controls = useControls("Background Smoke", {
    // Mesh properties
    positionX: { value: -0.16, min: -10, max: 10, step: 0.01 },
    positionY: { value: 1.5, min: -10, max: 10, step: 0.01 },
    positionZ: { value: -2.415, min: -10, max: 10, step: 0.01 },
    rotationY: { value: 0.05, min: -Math.PI, max: Math.PI, step: 0.01 },
    scale: { value: 96, min: 1, max: 120, step: 0.1 },

    // Material properties
    color: "#b2142e",
    opacity: { value: 3.8, min: 0, max: 10, step: 0.1 },
    transparent: true,
  })

  const [texture] = useTexture([
    getFullPath("/sunset-car/red-smoke-fog-2.webp"),
  ])

  useEffect(() => {
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping
    texture.colorSpace = "srgb"
    texture.needsUpdate = true
  }, [texture])

  return (
    <mesh
      position={[controls.positionX, controls.positionY, controls.positionZ]}
      rotation={[0, controls.rotationY, 0]}
      scale={controls.scale}
      castShadow={false}
      receiveShadow={false}
    >
      <cylinderGeometry args={[1, 1, 1, 32, 1, true]} />
      <meshBasicMaterial
        color={controls.color}
        map={texture}
        transparent={controls.transparent}
        opacity={controls.opacity}
        side={THREE.DoubleSide}
        fog={false}
      />
    </mesh>
  )
}

// Keep the original camera rig for reference
// function OriginalCameraRig() {
//   const { disableCameraRig } = useControls("Camera Rig", {
//     disableCameraRig: { value: false, label: "Disable Camera Rig" },
//   })

//   const controls = useThree((state) => state.controls)

//   const [vec] = useState(() => new THREE.Vector3())
//   useFrame((state) => {
//     if (!disableCameraRig) {
//       state.camera.position.lerp(
//         vec.set(-state.pointer.x * 2.5, 1 + state.pointer.y * 3, 5.5),
//         0.05
//       )
//       state.camera.lookAt(0, 0, 0)
//       controls
//     }
//   })

//   return (
//     <OrbitControls
//       enableDamping={disableCameraRig}
//       enablePan={disableCameraRig}
//       enableZoom={disableCameraRig}
//       maxPolarAngle={1.3}
//       enabled={disableCameraRig}
//     />
//   )
// }

function CameraRig({
  started,
  isMouseDownRef,
}: {
  started: boolean
  isMouseDownRef: React.MutableRefObject<boolean>
}) {
  const { disableCameraRig } = useControls("Camera Rig", {
    disableCameraRig: { value: false, label: "Disable Camera Rig" },
  })
  const cameraControlRef = useRef<CameraControls | null>(null)
  const [vec] = useState(() => new THREE.Vector3())
  const lastPosition = useRef(new THREE.Vector3(0, 6, 12))
  const targetPosition = useRef(new THREE.Vector3(0, 1, 5.5))
  const progress = useRef(0)

  // Dolly zoom state
  const dollyProgress = useRef(0)
  const originalFov = useRef(45)
  const originalDistance = useRef(30.5)

  useFrame((state, delta) => {
    const controls = cameraControlRef.current
    if (!controls) return

    if (started && progress.current < 1) {
      progress.current = Math.min(progress.current + delta * 0.5, 1)
      lastPosition.current.lerpVectors(
        new THREE.Vector3(0, 6, 1),
        targetPosition.current,
        progress.current
      )
      controls.setLookAt(
        lastPosition.current.x,
        lastPosition.current.y,
        lastPosition.current.z,
        0,
        0,
        0,
        false
      )
    } else if (started && progress.current >= 1 && !disableCameraRig) {
      // Handle dolly zoom effect using the passed ref
      if (isMouseDownRef.current) {
        dollyProgress.current = Math.min(dollyProgress.current + delta * 1.5, 1)
      } else {
        dollyProgress.current = Math.max(dollyProgress.current - delta * 1.5, 0)
      }

      const distanceChange = -5
      const fovChange = 20

      const currentDistance =
        originalDistance.current + distanceChange * dollyProgress.current
      const currentFov = originalFov.current + fovChange * dollyProgress.current

      const camera = state.camera as THREE.PerspectiveCamera
      camera.fov = currentFov
      camera.updateProjectionMatrix()

      const targetX = -state.pointer.x * 2.5
      const targetY = Math.max(1, 2 + state.pointer.y)
      const targetZ = currentDistance

      vec.set(targetX, targetY, targetZ)
      lastPosition.current.lerp(vec, 0.05)

      controls.setLookAt(
        lastPosition.current.x,
        lastPosition.current.y,
        lastPosition.current.z,
        0,
        0,
        0,
        false
      )
    }
  })

  return (
    <CameraControls
      ref={cameraControlRef}
      makeDefault
      enabled={disableCameraRig}
      maxPolarAngle={1.3}
    />
  )
}

export default function App() {
  // const isLoaded = useAppProgress() // 2. Check if loaded
  // const [loadingDone, setLoadingDone] = useState(false)
  const [started, setStarted] = useState(false)

  // useEffect(() => {
  //   if (isLoaded && !loadingDone) {
  //     // Use a short delay to ensure the state update happens AFTER the current
  //     // render/load cycle is complete.
  //     const timer = setTimeout(() => {
  //       setLoadingDone(true)
  //     }, 50)
  //     return () => clearTimeout(timer)
  //   }
  // }, [isLoaded, loadingDone]) // Runs when the loading status changes

  const { fogColor, fogStart, fogEnd } = useControls("Fog", {
    fogColor: "#f80000",
    fogStart: { value: 20, min: 0, max: 100, step: 1 },
    fogEnd: { value: 55, min: 0, max: 100, step: 1 },
  })

  const isMouseDownRef = useRef(false)
  const audioControlsRef = useRef<AudioPlayerControls | null>(null)

  const handleStartClick = () => {
    setStarted(true)
    audioControlsRef.current?.play()
  }

  return (
    <main className="w-full overflow-x-auto">
      <Leva collapsed hidden />

      {/* Loading screen - highest z-index */}
      {/* <div
        className="absolute inset-0 flex justify-center items-center bg-black transition-opacity duration-500"
        style={{
          zIndex: 200,
          opacity: loadingDone ? 0 : 1,
          pointerEvents: loadingDone ? "none" : "auto",
        }}
      >
        <Loader
          containerStyles={{ background: "black" }}
          dataInterpolation={(p) => `Loading ${p.toFixed(0)}%`}
        />
      </div> */}

      {/* Overlay - middle z-index */}
      {/* <FullScreenLoader loadingDone={loadingDone} /> */}
      {/* <Overlay2
        loadingDone={loadingDone}
        onStartClick={handleStartClick} // <-- Use the handler that calls play()
        started={started}
      /> */}
      {/* Reusable Loading + Start Overlay */}
      <IntroOverlay
        onStart={handleStartClick}
        startText="Click to Begin"
        backgroundColor="#000"
      />
      <Canvas
        shadows
        camera={{ position: [0, 3, 34], fov: 45 }}
        onPointerDown={() => {
          isMouseDownRef.current = true
        }}
        onPointerUp={() => {
          isMouseDownRef.current = false
        }}
        onPointerLeave={() => {
          isMouseDownRef.current = false
        }}
      >
        {/* <LoadingManager onLoadComplete={() => setLoadingDone(true)} /> */}

        <color attach="background" args={["#000"]} />
        <fog attach="fog" args={[fogColor, fogStart, fogEnd]} />
        <Suspense fallback={null}>
          {started && (
            <Html fullscreen className="pointer-events-none">
              <h2 className="text-center text-lg text-white">
                Click and hold to see Vertigo effect
              </h2>
            </Html>
          )}
          <Lights />
          <BackgroundPoster />
          <BackgroundSmoke />
          <LoopingTerrain />
          <BMWCar2 />
          <SelectEnv />
          <AudioPlayer
            ref={audioControlsRef}
            src={getFullPath("/music/car-beat.mp3")}
            volume={0.6}
            loop
          />
        </Suspense>
        <CameraRig started={started} isMouseDownRef={isMouseDownRef} />
        <ToneMapping />
        <Stats />
      </Canvas>
    </main>
  )
}
